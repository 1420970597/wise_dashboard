import{r as v,H as St}from"./react-DaKiOxKV.js";import{d as Xt,s as Qt}from"./vendor-DQu9Rupt.js";const jt=0,qt=1,Ut=2,Ft=3,P=new WeakMap,j=()=>{},D=j(),mt=Object,i=t=>t===D,N=t=>typeof t=="function",q=(t,e)=>({...t,...e}),Ht=t=>N(t.then),ut={},st={},Dt="undefined",Q=typeof window!=Dt,pt=typeof document!=Dt,Zt=Q&&"Deno"in window,te=()=>Q&&typeof window.requestAnimationFrame!=Dt,$t=(t,e)=>{const n=P.get(t);return[()=>!i(e)&&t.get(e)||ut,r=>{if(!i(e)){const c=t.get(e);e in st||(st[e]=c),n[5](e,q(c,r),c||ut)}},n[6],()=>!i(e)&&e in st?st[e]:!i(e)&&t.get(e)||ut]};let ht=!0;const ee=()=>ht,[gt,wt]=Q&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[j,j],ne=()=>{const t=pt&&document.visibilityState;return i(t)||t!=="hidden"},se=t=>(pt&&document.addEventListener("visibilitychange",t),gt("focus",t),()=>{pt&&document.removeEventListener("visibilitychange",t),wt("focus",t)}),oe=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return gt("online",e),gt("offline",n),()=>{wt("online",e),wt("offline",n)}},re={isOnline:ee,isVisible:ne},ie={initFocus:se,initReconnect:oe},Wt=!St.useId,X=!Q||Zt,ae=t=>te()?window.requestAnimationFrame(t):setTimeout(t,1),lt=X?v.useEffect:v.useLayoutEffect,ft=typeof navigator<"u"&&navigator.connection,xt=!X&&ft&&(["slow-2g","2g"].includes(ft.effectiveType)||ft.saveData),ot=new WeakMap,ce=t=>mt.prototype.toString.call(t),dt=(t,e)=>t===`[object ${e}]`;let ue=0;const vt=t=>{const e=typeof t,n=ce(t),r=dt(n,"Date"),c=dt(n,"RegExp"),l=dt(n,"Object");let o,u;if(mt(t)===t&&!r&&!c){if(o=ot.get(t),o)return o;if(o=++ue+"~",ot.set(t,o),Array.isArray(t)){for(o="@",u=0;u<t.length;u++)o+=vt(t[u])+",";ot.set(t,o)}if(l){o="#";const R=mt.keys(t).sort();for(;!i(u=R.pop());)i(t[u])||(o+=u+":"+vt(t[u])+",");ot.set(t,o)}}else o=r?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return o},Tt=t=>{if(N(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?vt(t):"",[t,e]};let le=0;const Ot=()=>++le;async function kt(...t){const[e,n,r,c]=t,l=q({populateCache:!0,throwOnError:!0},typeof c=="boolean"?{revalidate:c}:c||{});let o=l.populateCache;const u=l.rollbackOnError;let R=l.optimisticData;const I=T=>typeof u=="function"?u(T):u!==!1,O=l.throwOnError;if(N(n)){const T=n,m=[],A=e.keys();for(const p of A)!/^\$(inf|sub)\$/.test(p)&&T(e.get(p)._k)&&m.push(p);return Promise.all(m.map(g))}return g(n);async function g(T){const[m]=Tt(T);if(!m)return;const[A,p]=$t(e,m),[rt,s,Z,J]=P.get(e),M=()=>{const _=rt[m];return(N(l.revalidate)?l.revalidate(A().data,T):l.revalidate!==!1)&&(delete Z[m],delete J[m],_&&_[0])?_[0](Ut).then(()=>A().data):A().data};if(t.length<3)return M();let S=r,F,L=!1;const E=Ot();s[m]=[E,0];const $=!i(R),V=A(),k=V.data,tt=V._c,U=i(tt)?k:tt;if($&&(R=N(R)?R(U,k):R,p({data:R,_c:U})),N(S))try{S=S(U)}catch(_){F=_,L=!0}if(S&&Ht(S))if(S=await S.catch(_=>{F=_,L=!0}),E!==s[m][0]){if(L)throw F;return S}else L&&$&&I(F)&&(o=!0,p({data:U,_c:D}));if(o&&!L)if(N(o)){const _=o(S,U);p({data:_,error:D,_c:D})}else p({data:S,error:D,_c:D});if(s[m][1]=Ot(),Promise.resolve(M()).then(()=>{p({_c:D})}),L){if(O)throw F;return}return S}}const Pt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},fe=(t,e)=>{if(!P.has(t)){const n=q(ie,e),r=Object.create(null),c=kt.bind(D,t);let l=j;const o=Object.create(null),u=(O,g)=>{const T=o[O]||[];return o[O]=T,T.push(g),()=>T.splice(T.indexOf(g),1)},R=(O,g,T)=>{t.set(O,g);const m=o[O];if(m)for(const A of m)A(g,T)},I=()=>{if(!P.has(t)&&(P.set(t,[r,Object.create(null),Object.create(null),Object.create(null),c,R,u]),!X)){const O=n.initFocus(setTimeout.bind(D,Pt.bind(D,r,jt))),g=n.initReconnect(setTimeout.bind(D,Pt.bind(D,r,qt)));l=()=>{O&&O(),g&&g(),P.delete(t)}}};return I(),[t,c,I,l]}return[t,P.get(t)[4]]},de=(t,e,n,r,c)=>{const l=n.errorRetryCount,o=c.retryCount,u=~~((Math.random()+.5)*(1<<(o<8?o:8)))*n.errorRetryInterval;!i(l)&&o>l||setTimeout(r,u,c)},Ee=Xt,[Bt,Re]=fe(new Map),me=q({onLoadingSlow:j,onSuccess:j,onError:j,onErrorRetry:de,onDiscarded:j,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:xt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:xt?5e3:3e3,compare:Ee,isPaused:()=>!1,cache:Bt,mutate:Re,fallback:{}},re),pe=(t,e)=>{const n=q(t,e);if(e){const{use:r,fallback:c}=t,{use:l,fallback:o}=e;r&&l&&(n.use=r.concat(l)),c&&o&&(n.fallback=q(c,o))}return n},he=v.createContext({}),ge="$inf$",Kt=Q&&window.__SWR_DEVTOOLS_USE__,we=Kt?window.__SWR_DEVTOOLS_USE__:[],ve=()=>{Kt&&(window.__SWR_DEVTOOLS_REACT__=St)},Oe=t=>N(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],Se=()=>{const t=v.useContext(he);return v.useMemo(()=>q(me,t),[t])},De=t=>(e,n,r)=>t(e,n&&((...l)=>{const[o]=Tt(e),[,,,u]=P.get(Bt);if(o.startsWith(ge))return n(...l);const R=u[o];return i(R)?n(...l):(delete u[o],R)}),r),Te=we.concat(De),_e=t=>function(...n){const r=Se(),[c,l,o]=Oe(n),u=pe(r,o);let R=t;const{use:I}=u,O=(I||[]).concat(Te);for(let g=O.length;g--;)R=O[g](R);return R(c,l||u.fetcher||null,u)},Ce=(t,e,n)=>{const r=e[t]||(e[t]=[]);return r.push(n),()=>{const c=r.indexOf(n);c>=0&&(r[c]=r[r.length-1],r.pop())}};ve();const Et=St.use||(t=>{switch(t.status){case"pending":throw t;case"fulfilled":return t.value;case"rejected":throw t.reason;default:throw t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t}}),Rt={dedupe:!0},Mt=Promise.resolve(D),be=(t,e,n)=>{const{cache:r,compare:c,suspense:l,fallbackData:o,revalidateOnMount:u,revalidateIfStale:R,refreshInterval:I,refreshWhenHidden:O,refreshWhenOffline:g,keepPreviousData:T}=n,[m,A,p,rt]=P.get(r),[s,Z]=Tt(t),J=v.useRef(!1),M=v.useRef(!1),S=v.useRef(s),F=v.useRef(e),L=v.useRef(n),E=()=>L.current,$=()=>E().isVisible()&&E().isOnline(),[V,k,tt,U]=$t(r,s),_=v.useRef({}).current,G=i(o)?i(n.fallback)?D:n.fallback[s]:o,_t=(a,d)=>{for(const h in _){const f=h;if(f==="data"){if(!c(a[f],d[f])&&(!i(a[f])||!c(nt,d[f])))return!1}else if(d[f]!==a[f])return!1}return!0},Ct=v.useMemo(()=>{const a=!s||!e?!1:i(u)?E().isPaused()||l?!1:R!==!1:u,d=C=>{const W=q(C);return delete W._k,a?{isValidating:!0,isLoading:!0,...W}:W},h=V(),f=U(),y=d(h),z=h===f?y:d(f);let w=y;return[()=>{const C=d(V());return _t(C,w)?(w.data=C.data,w.isLoading=C.isLoading,w.isValidating=C.isValidating,w.error=C.error,w):(w=C,C)},()=>z]},[r,s]),B=Qt.useSyncExternalStore(v.useCallback(a=>tt(s,(d,h)=>{_t(h,d)||a()}),[r,s]),Ct[0],Ct[1]),bt=!J.current,zt=m[s]&&m[s].length>0,K=B.data,H=i(K)?G&&Ht(G)?Et(G):G:K,et=B.error,it=v.useRef(H),nt=T?i(K)?i(it.current)?H:it.current:K:H,It=zt&&!i(et)?!1:bt&&!i(u)?u:E().isPaused()?!1:l?i(H)?!1:R:i(H)||R,yt=!!(s&&e&&bt&&It),Jt=i(B.isValidating)?yt:B.isValidating,Gt=i(B.isLoading)?yt:B.isLoading,Y=v.useCallback(async a=>{const d=F.current;if(!s||!d||M.current||E().isPaused())return!1;let h,f,y=!0;const z=a||{},w=!p[s]||!z.dedupe,C=()=>Wt?!M.current&&s===S.current&&J.current:s===S.current,W={isValidating:!1,isLoading:!1},Lt=()=>{k(W)},Vt=()=>{const b=p[s];b&&b[1]===f&&delete p[s]},Nt={isValidating:!0};i(V().data)&&(Nt.isLoading=!0);try{if(w&&(k(Nt),n.loadingTimeout&&i(V().data)&&setTimeout(()=>{y&&C()&&E().onLoadingSlow(s,n)},n.loadingTimeout),p[s]=[d(Z),Ot()]),[h,f]=p[s],h=await h,w&&setTimeout(Vt,n.dedupingInterval),!p[s]||p[s][1]!==f)return w&&C()&&E().onDiscarded(s),!1;W.error=D;const b=A[s];if(!i(b)&&(f<=b[0]||f<=b[1]||b[1]===0))return Lt(),w&&C()&&E().onDiscarded(s),!1;const x=V().data;W.data=c(x,h)?x:h,w&&C()&&E().onSuccess(h,s,n)}catch(b){Vt();const x=E(),{shouldRetryOnError:at}=x;x.isPaused()||(W.error=b,w&&C()&&(x.onError(b,s,x),(at===!0||N(at)&&at(b))&&(!E().revalidateOnFocus||!E().revalidateOnReconnect||$())&&x.onErrorRetry(b,s,x,Yt=>{const ct=m[s];ct&&ct[0]&&ct[0](Ft,Yt)},{retryCount:(z.retryCount||0)+1,dedupe:!0})))}return y=!1,Lt(),!0},[s,r]),At=v.useCallback((...a)=>kt(r,S.current,...a),[]);if(lt(()=>{F.current=e,L.current=n,i(K)||(it.current=K)}),lt(()=>{if(!s)return;const a=Y.bind(D,Rt);let d=0;E().revalidateOnFocus&&(d=Date.now()+E().focusThrottleInterval);const f=Ce(s,m,(y,z={})=>{if(y==jt){const w=Date.now();E().revalidateOnFocus&&w>d&&$()&&(d=w+E().focusThrottleInterval,a())}else if(y==qt)E().revalidateOnReconnect&&$()&&a();else{if(y==Ut)return Y();if(y==Ft)return Y(z)}});return M.current=!1,S.current=s,J.current=!0,k({_k:Z}),It&&(p[s]||(i(H)||X?a():ae(a))),()=>{M.current=!0,f()}},[s]),lt(()=>{let a;function d(){const f=N(I)?I(V().data):I;f&&a!==-1&&(a=setTimeout(h,f))}function h(){!V().error&&(O||E().isVisible())&&(g||E().isOnline())?Y(Rt).then(d):d()}return d(),()=>{a&&(clearTimeout(a),a=-1)}},[I,O,g,s]),v.useDebugValue(nt),l){const a=s&&i(H);if(!Wt&&X&&a)throw new Error("Fallback data is required when using Suspense in SSR.");a&&(F.current=e,L.current=n,M.current=!1);const d=rt[s],h=!i(d)&&a?At(d):Mt;if(Et(h),!i(et)&&a)throw et;const f=a?Y(Rt):Mt;!i(nt)&&a&&(f.status="fulfilled",f.value=!0),Et(f)}return{mutate:At,get data(){return _.data=!0,nt},get error(){return _.error=!0,et},get isValidating(){return _.isValidating=!0,Jt},get isLoading(){return _.isLoading=!0,Gt}}},Le=_e(be);export{Re as m,Le as u};
